import { observable, computed, action } from 'mobx' import _ from 'lodash' import moment from 'moment' import Posts from './_posts' import firebase from './_firebase' import user from './_user' import messages from './_messages' import Reservation from './_reservation' import makeGuide from './_guide' import clock from './_clock' import { getOutin } from './api/_aircal' import * as airmicro from './api/_airmicro' import * as airpost from './api/_airpost' export default class Thread { // Essential Data @observable id @observable time @observable last_post_time @observable posts = [] //post store @observable data = {} @observable tags = [] @observable outin = {} // Room data @observable loaded = false @observable listing = {} @observable rooms = [] @observable building = [] @observable reservations = [] @observable host = {} // Chat text store @observable inputText = '' @observable inputCursorPos = 0 // Note data @observable noteListing @observable noteGuest @observable renderNoteListing = false @observable renderNoteGuest = false // State data @observable justUpdated = false @observable chatExpanded = false @observable minimized = false @observable mounted = false firstUpdate = true constructor(id, data) { console.log('Thread loading ' + id) if (!data) { this.initNoData(id) } else { this.init(id, data) } } async initNoData(id) { let fbThreadRef = firebase.database().ref(`group_data/${user.group}/hot/threads/${id}`) fbThreadRef.on('value', s => { this.init(id, s.val()) }) } async init(id, data) { this.id = id this.data = data.data this.tags = data.tags this.time = data.time this.last_post_time = data.last_post_time this.posts = new Posts(this, data.data.posts) //////////////// // Data fetching if (this.data.listing_id) { this.listing = (await firebase .database() .ref(`group_data/${user.group}/data/airbnb_listings/${this.data.listing_id}`) .once('value')).val() } if (!this.listing) { console.log('No listing found for thread ' + this.id) } if (this.data.offer) { this.data.outin = getOutin( this.listing.rooms.map(r => r.ref), this.data.offer.check_in, this.data.offer.check_out ) } if (this.listing) { this.listing.rooms = await Promise.all( _.map(this.listing.rooms, async roomRef => { let room = (await firebase .database() .ref(`group_data/${user.group}/data/rooms/${roomRef}`) .once('value')).val() if (room) { room.wifi = (await firebase .database() .ref(`group_data/${user.group}/data/wifis/${room.wifi}`) .once('value')).val() room.building = (await firebase .database() .ref(`group_data/${user.group}/data/buildings/${room.building}`) .once('value')).val() room.security = (await firebase .database() .ref(`group_data/${user.group}/data/securities/${room.security}`) .once('value')).val() } return room }) ) this.host = (await firebase .database() .ref(`group_data/${user.group}/data/airbnb_hosts/${this.data.host.id}`) .once('value')).val() } if (this.data.reservations && this.data.reservations.length > 0) { await Promise.all( _.map(this.data.reservations, async rId => { let reservation = (await firebase .database() .ref(`group_data/${user.group}/hot/reservations/${rId}`) .once('value')).val() // console.log(reservation) if (reservation) { this.reservations.push(new Reservation(reservation.data.id, reservation)) return reservation } }) ) if (this.currentReservation) { const start = this.currentReservation.data.check_in const end = this.currentReservation.data.check_out const rooms = this.listing.rooms.map(r => r.ref) // console.log(rooms, start, end) this.outin = getOutin(rooms, start, end) } } this.loaded = true firebase .database() .ref(`group_data/${user.group}/hot/threads/${this.id}`) .on('value', snapshot => { const data = snapshot.val() if (data) { this.update(snapshot.val()) } }) firebase .database() .ref(`group_data/${user.group}/hot/notes/guests/${this.data.id}`) .on('value', snapshot => { this.noteGuest = snapshot.val() }) firebase .database() .ref(`group_data/${user.group}/hot/notes/listings/${this.listing.id}`) .on('value', snapshot => { this.noteListing = snapshot.val() }) this.initialiseInput() } @action update(data) { // this.id = id this.data = data.data this.posts.update(data.data.posts) this.tags = data.tags this.time = data.time if (this.firstUpdate) { this.firstUpdate = false } else { this.justUpdated = true setTimeout( function() { this.justUpdated = false }.bind(this), 5000 ) } } @action async archive() { const node = (await firebase .database() .ref(`group_data/${user.group}/hot/threads/${this.id}`) .once('value')).val() firebase .database() .ref(`group_data/${user.group}/hot/threads_archive/${this.id}`) .set(node) firebase .database() .ref(`group_data/${user.group}/hot/threads/${this.id}`) .remove() } @action initialiseInput() { if (this.loaded) { let msg = messages.defaults[this.statusFull.simpleStatus] || null if (!msg) { msg = messages.defaults.generic } this.overwriteMessage(this.replaceTemplateMarkersWithData(msg.en)) } } @action async putGuideInChat() { this.inputText = await makeGuide(this, 'en') } replaceTemplateMarkersWithData(msg) { msg = msg.replace('___GUESTNAME___', this.data.guest.first_name) const dates = this.currentReservationDatesForMessages if (dates) { msg = msg.replace('___CHECKINDATE___', dates.start) msg = msg.replace('___CHECKOUTDATE___', dates.end) } const wifiNetworks = _.map(this.listing.rooms, room => room.wifi.network_name).join(' and ') msg = msg.replace('___WIFINETWORK___', wifiNetworks) const wifiPasswords = _.map(this.listing.rooms, room => room.wifi.password).join(' and ') msg = msg.replace('___WIFIPASSWORD___', wifiPasswords) if (this.listing.rooms[0]) { msg = msg.replace('___ADDRESS___', this.listing.rooms[0].building.japanese) } return msg + '\n' } @action async sendMessage() { const message = this.inputText.slice() this.addPendingPost() this.updateTextInput('') await airpost.sendMessage(this.host.token, this.data.id, message) await airmicro.refreshThread(this.data.host.id, this.data.id) } @action async refreshThread() { console.log(await airmicro.refreshThread(this.data.host.id, this.data.id)) } @action addPendingPost() { const post = { created_at: moment().toISOString(), id: this.posts.lastPostId + 1, message: this.inputText.slice(), user_id: this.data.host.id, pending: true } this.inputText = '' this.posts.addPendingPost(post) } @action updateTextInput(text) { this.inputText = text this.inputCursorPos = text.length } @action insertQuickMessage(messageName) { const message = this.replaceTemplateMarkersWithData(messages.messages[messageName].en) this.insertMessageAtCursor(message) } @action insertGuide(type) { // TODO: make subtypes this.putGuideInChat() } @action insertMessageAtCursor(message) { this.inputText = this.inputText.substr(0, this.inputCursorPos) + message + this.inputText.substr(this.inputCursorPos) this.inputCursorPos = this.inputText.length } @action overwriteMessage(message) { this.inputText = message this.inputCursorPos = this.inputText.length } @computed get messagesByGroup() { return messages.filterByStatusAndGroup(this.statusFull.simpleStatus) } @computed get isMultiRoom() { if (this.listing.rooms) return this.listing.rooms.length > 1 else return false } @computed get hostId() { return this.data.host ? this.data.host.id : null } @computed get room() { return this.listing.rooms ? this.listing.rooms[0] : null } @computed get heading() { return `${this.data.guest.first_name} > ${this.listing.code} > ${this.statusFull.status}` } @computed get formattedTags() { if (this.tags) { return this.tags.map(tag => { let out const split = tag.split(':') out = split.join(' (') + ')' if (split[0] === 'new-post') out = 'new post' if (split[0] === 'new-thread') out = 'new thread (in system)' return out }) } else return [] } @computed get publishTime() { return moment(this.last_post_time).format('HH:mm:ss MM/DD') } @computed get publishTimeDynamicRelative() { return moment(this.last_post_time).from(clock.now) } @computed get currentReservation() { if (this.reservations) { const numRes = this.reservations.length if (numRes === 1) { return this.reservations[0] } for (let i = 0; i < numRes; i++) { // Loops through reservation array looking for next reservation const r = this.reservations[i] if (i === numRes - 1 || !moment().isAfter(r.check_out)) { return r } } } } @computed get currentOffer() { if (this.data) { return this.data.offer } else return null } @computed get lastPostId() { if (this.posts) { return this.posts.lastActivePost.id } else { return 0 } } @computed get currentReservationOrOffer() { return (this.currentReservation ? this.currentReservation.data : null) || this.currentOffer } @computed get currentReservationDates() { // let r = this.currentReservation.data // let out = {verbose: {}, brief: {}, outin: {}} // if(r) { // out.verbose.start = moment(r.check_in).format('dddd, MMMM Do YYYY') // out.verbose.end = moment(r.check_out).format('dddd, MMMM Do YYYY') // out.brief.start = moment(r.check_in).format('MM/DD') // out.brief.end = moment(r.check_out).format('MM/DD') // out.year = moment(r.check_out).format('YYYY') // // out.outin.start = this.outin.before // out.outin.end = this.outin.after // // } // return out return this.formatResOfferDateStrings(this.currentReservation.data) } @computed get currentOfferDates() { return this.formatResOfferDateStrings(this.currentOffer) } @computed get currentAlteration() { return _.reduce( this.reservations, (acc, reservation) => reservation.pendingAlteration || acc, null ) } @computed get currentAlterationDates() { const r = this.currentAlteration let out = { verbose: {}, brief: {}, outin: {} } if (r) { out.verbose.start = moment(r.check_in).format('dddd, MMMM Do YYYY') out.verbose.end = moment(r.check_out).format('dddd, MMMM Do YYYY') out.brief.start = moment(r.check_in).format('MM/DD') out.brief.end = moment(r.check_out).format('MM/DD') out.year = moment(r.check_out).format('YYYY') out.nights = moment(r.check_out).diff(r.check_in, 'days') } return out // return this.formatResOfferDateStrings(this.currentReservation.data) } @computed get currentAlterations() { return _.filter( _.map(this.reservations, reservation => reservation.pendingAlteration), _.identity ) } @action toggleGuestNote() { this.renderNoteGuest = !this.renderNoteGuest } @action toggleListingNote() { this.renderNoteListing = !this.renderNoteListing } @action changeGuestNote(text) { if (user.group && this.data) { this.noteGuest = text // TODO: save in firebase firebase .database() .ref(`group_data/${user.group}/hot/notes/guests/${this.data.id}`) .set(this.noteGuest) } } @action changeListingNote(text) { this.noteListing = text if (user.group && this.listing) { this.noteListing = text // TODO: save in firebase firebase .database() .ref(`group_data/${user.group}/hot/notes/listings/${this.listing.id}`) .set(this.noteListing) } } @action toggleChatExpanded() { this.chatExpanded = !this.chatExpanded } // moved @action formatResOfferDateStrings(r) { let out = { verbose: {}, brief: {}, outin: {} } if (r) { out.verbose.start = moment(r.check_in).format('dddd, MMMM Do YYYY') out.verbose.end = moment(r.check_out).format('dddd, MMMM Do YYYY') out.brief.start = moment(r.check_in).format('MM/DD') out.brief.end = moment(r.check_out).format('MM/DD') out.year = moment(r.check_out).format('YYYY') if (this.outin) { out.outin.start = this.outin.before ? '(out/in) ' : '' out.outin.end = this.outin.after ? '(out/in) ' : '' } } return out } // moved to reservation object @computed get currentReservationDatesForMessages() { // Today || Tommorrow || 15th of June || etc.. let out let r = this.currentReservationOrOffer if (r) { out = {} if (moment().isSame(r.check_in, 'day')) { out.start = 'today' } else if ( moment() .add(1, 'day') .isSame(r.check_in, 'day') ) { out.start = 'tomorrow' } else { out.start = moment(r.check_in).format('MMMM [the] Do') } if (moment().isSame(r.check_out, 'day')) { out.end = 'today' } else if ( moment() .add(1, 'day') .isSame(r.check_out, 'day') ) { out.end = 'tomorrow' } else { out.end = moment(r.check_out).format('MMMM [the] Do') } } return out } @computed get isResponded() { if (this.loaded) { return this.posts.isResponded } else return false } @computed get statusFull() { if (this.data) { const simpleStatusString = function(s) { if (!s) return undefined if (s === 'accepted') return 'Confirmed' if (s === 'preapproved') return 'Inquiry' if (s === 'cancelled') return 'Cancelled' if (s === 'not_possible') return 'Not Possible' if (s === 'special_offer') return 'Special Offer' if (s === 'pending_verification') return 'Awaiting Account Verification' if (s === 'awaiting_payment') return 'Awaiting Payment' if (s === 'denied') return 'Denied' if (s === 'timedout') return 'Expired' if (s === 'inquiry') return 'Inquiry' if (s === 'pending') return 'Request' return 'Message' } let status = simpleStatusString(this.data.status) let simpleStatus = '' let iconName = 'question circle' if (status === 'Confirmed') { if (this.currentReservation) { const info = this.currentReservation.descriptiveStatus status = info.status simpleStatus = info.simpleStatus iconName = info.iconName } } else if (status === 'Inquiry') { simpleStatus = 'inquiry' } else if (status === 'Request') { simpleStatus = 'request' } else if (status === 'Cancelled') { simpleStatus = 'cancelled' } else if (status === 'Not Possible') { simpleStatus = 'not-possible' } else if (status === 'Expired') { simpleStatus = 'expired' } else if (status === 'Special Offer') { simpleStatus = 'special-offer' } else if (status === 'Awaiting Payment') { simpleStatus = 'awaiting-payment' } else if (status === 'Awaiting Account Verification') { simpleStatus = 'checking-account' } else if (status === 'Message') { simpleStatus = 'message' } return { status, simpleStatus, iconName } } else { return { status: null, simpleStatus: null, iconName: null } } } @computed get colorCode() { let colorCode = 'black' // console.log(this.data.guest.name, this.statusFull.status, this.statusFull.simpleStatus) switch (this.statusFull.simpleStatus) { case 'confirmed': colorCode = 'blue' break case 'check-in': colorCode = 'green' break case 'staying': colorCode = 'yellow' break case 'check-out': colorCode = 'teal' break case 'finished': colorCode = 'olive' break case 'inquiry': colorCode = 'orange' break case 'request': colorCode = 'pink' break case 'cancelled': colorCode = 'purple' break case 'not-possible': colorCode = 'black' break case 'expired': colorCode = 'olive' break case 'special-offer': colorCode = 'brown' break case 'awaiting-payment': colorCode = 'violet' break case 'checking-account': colorCode = 'red' break default: colorCode = 'grey' } return colorCode } } 
